<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM垃圾回收]]></title>
    <url>%2F2019%2F09%2F20%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[&emsp;垃圾收集是C++与Java的一大不同点，C++中需要手动释放内存，编写析构函数。而JVM则由后台垃圾收集线程帮我们处理垃圾对象，减少了开发人员写代码忘记编写析构，或错误析构的可能。在JVM内存结构中已经大致了解过heap堆的分代。现在的垃圾收集器基本都采用分代收集算法。因为某论文中证明大多数对象是朝生夕死的，分代算法提高垃圾收集的效率。 标记垃圾对象&emsp;那么，首先的问题是，JVM怎么知道哪些对象是需要收集的呢？在对象头的Mark Word标记字中，锁标志位（01无锁或偏向锁，00轻量级锁，10重量级锁，11GC标记）为11的话就表示该对象就要被回收了。那么是用什么方法进行标记的呢？ 引用计数法&emsp;引用计数法就是给对象加一个引用计数器，统计该对象被引用的次数，当被引用后+1，引用失效就-1，如果为0则表示当前没有其他地方引用这个对象了，就可以回收了。似乎这样的算法很简单，也容易实现。但是，存在这样一种情况，A对象引用B,而B对象又引用A，他们相互引用，那么计数则永远不可能为0，这时就无法回收A和B。所以JVM的垃圾收集一般不采用这种算法。 可达性分析-GC Roots&emsp;可达性分析算法就是 将一些对象作为根节点即GC Root，向下搜索它的字段，搜索走过的路径叫做引用链refrence Chain,那么当一个对象到 GC Roots没有一个引用链与之相连（图论中就是GC Root到这个对象不可达），那么对象就是不可用的，需要清理。如下图所示： 可达性分析-GC Roots &emsp;从图中可以看到，方法区中类的静态属性，方法区中的常量，虚拟机栈中的局部变量 可以作为GC Root,从它们出发，区分开可用和不可用对象。那么当执行系统停顿下来后，并不需要一个不漏地检查完所有局部变量和全局的引用位置，在Hotspot实现中，是使用一组称为OopMap的数据结构来直接记录哪些地方存放着对象引用。在JIT编译过程中，也会记录下栈和寄存器中哪些位置是引用，这样GC在扫描时就可以准确知道这些对象的引用。 Stop-The-World&emsp;标记完对象就要开始清理了，那这个过程最好理解的就是，把用户的线程全部停下来，垃圾收集线程开始清理，如果一边清理，用户线程一边运行，那可能就会产生新的要回收的垃圾对象。就好比，你妈妈在打扫房间，你还一个劲的往地上扔垃圾，这样怎么打扫得干净呢。所以，垃圾清理线程工作的时候，其他用户线程都应该停止。 &emsp;这个过程就叫做Stop-The-World,顾名思义，对用户Java线程，就好像全世界都停止了一样。当要进行GC的时候,JVM会告诉所有线程，我要进行GC了，那么所有线程就会暂停等待。是怎么暂停等待的呢？总不能马上停止吧（下条指令就暂停）？那么接下来就讲讲安全点safe point。 安全点与安全区&emsp;JVM已经告知了要进行GC了，线程运行到安全点，会去检查是否要GC,是则等待。那么安全点在哪呢？安全点的选择不可能太多，太多则浪费了程序性能，太少则会让GC等待时间太长。所以安全点的选定一般是以“让程序运行得更久的特征”为标准选定的,因为指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行（一般方法的代码不会太长），“长时间执行”的最明显特征就是指令序列的复用，例如方法调用（Htospot方法调用临返回前），循环跳转（uncount loop非计数循环的回跳），异常跳转等，所有具有这些功能的指令才会产生safepoint。 TODO:可以测试一下counted loop是否会进入safe point以让GC开始。好像测试结果计数循环也会产生GC啊。 &emsp;那如果线程此时不在运行（处于sleep或blocked），这样就无法运行到安全点停止，JVM也不可能等到线程唤醒后再执行到安全点中断挂起。对于这种情况就需要安全区解决。 &emsp;安全区是指在一段代码中，对象的引用关系不会发生变化。这样在这个区域的任何地方开始GC都是安全的。在线程执行到安全区的代码时，会标识自己已经进入安全区了，那样在这段时间里JVM发起GC时，就不用管标识为safe region状态的线程了。在线程离开safe region时，会检查系统是否已完成了GC(枚举GC Root或清理)，如果完成了就继续执行，否则它就必须等到收到可以离开safe region的信号为止。 详细了解 R大对safe point的解释 垃圾收集算法&emsp;这部分呢，只对算法进行一个大概的讲解。理解了算法的精髓，对于垃圾收集的整个过程也就有了整体的认识。不要求太多的细节，理解每种算法思想，它的优势，劣势。 标记-清除&emsp;标记-清除（Mark-Sweep）算法,前面已经讲过如何进行标记了，标记完后，进行清除，因为java堆是逻辑连续的（虚拟内存上看是连续，实际物理内存不一定），清理掉的对象就会形成内存碎片，那么以后在分配大对象的时候，明明还有可用内存，却无法找到一块足够放得下的内存而不得不触发另一种垃圾收集动作。这种算法易产生内存碎片，同时清理对象效率也不高。分配新对象的内存时，需要使用空闲内存列表来分配，这种分配方法叫空闲列表free-list。 标记-清除算法 复制&emsp;复制算法Copying，将内存划分为大小相等的两块，标记完成后，将可用对象复制到另一块内存，清空第一块内存，相比清除算法，这样清理动作就效率很高，同时分配内存的时候，只需要往后追加就行（指针加法bump-the-pointer），但是会有一半的内存不能使用，造成一半空间浪费。 标记-复制算法 标记-整理&emsp;标记-整理（Mark-Compact）标记完成后，将可用内存依次移动到一起，最后清除掉剩余部分的内存，这样就形成了连续的内存，不存在内存碎片。虽然清除动作很高效，但是整理的过程效率不好，还要改变对象之间引用的地址关系。 标记整理算法 #### 分代收集算法 &emsp;国外某某发布的一篇论文中证明大部分对象都是朝生夕死的，只有少部分的对象存活了下来。所以结合前面几种算法，将java堆划分为年轻代，老年代，年轻代又划分为Eden, from survivor(s0),to survivor(s1),默认比例是eden:s0:s1=8:1:1。通常在年轻代的eden区分配新对象，GC时，将eden区和from survivor中的存活对象采用复制算法复制到to survivor，然后交换s0,s1身份。如果from survivor有存活了好几代的对象，则将它晋升到老年代。如果eden + from survivor存活对象大小>to survivor大小，则有部分对象也会晋升。老年代因为是长期存活下来的对象，意味着它变动不大，当老年代因为晋升或者分配大对象而内存不够时便会发生GC,此时采用的算法一般是标记-清理或标记-整理。 年轻代使用-Xmn128m(memory new)指定大小。老年代则是当前java堆大小减去Xmn,java堆由Xms(memory start)和Xmx(memory max)指定。 分代收集算法 垃圾收集器&emsp;提前说明：下方的并发是指多个垃圾收集线程同时工作，并行是指多个垃圾收集线程与用户线程同时运行。 Serial 新生代，单线程 Serial Old 老年代，单线程 ParNew serial多线程版本，并发 Parallel Old 老年代多线程版本，并发 Parallel Scavenge（新生代、多线程并行、控制吞吐量、自适应分区比例） CMS(Concurrent Mark Sweep、老年代、多线程、并发) G1（Garbage-First，更小分区，新生和老年都收集，多线程，并行） 内存分配与回收策略新对象优先在年轻代Eden区分配&emsp;分配时有指针加法和空闲列表两种方式。并且每个线程都有自己的TLAB。 大对象直接进老年代长期存活对象进老年代&emsp;达到-XX:MaxTenuringThrehold年龄的survivor中的对象晋升到老年代 动态对象年龄判定当survivor区中存活对象相同年龄的所有对象大小大于survivor的一半，那么年龄&gt;=该年龄的对象就可以直接进入老年代，无需等到JVM选项-XX:MaxTenuringThrehold要求的年龄 空间分配担保只要老年代剩余连续可用空间大于当前新生代对象总和或历次从新生代晋升到老年代的平均晋升大小，则进行minorGC,如果失败，否则进行Full GC GC日志]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构]]></title>
    <url>%2F2019%2F09%2F17%2Fjvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[虚拟内存与JVM内存结构&emsp;在我们学习c语言/操作系统的时候，知道进程的内存结构有代码段，数据段[初始化数据段（初始化的全局和静态变量），未初始化数据段(又称bbs，未初始化的全局变量和静态变量)]，堆，共享库，栈，内核空间。详细了解可以搜索虚拟内存相关知识。 图1.虚拟内存结构 &emsp;虚拟机的内存结构与进程的虚拟内存结构类似，那么Java虚拟机是怎么抽象它的内存结构的呢？根据Java虚拟机规范，JVM所管理的内存包含以下几个运行时区域。可以按线程隔离和共享来分类。共享的有堆、方法区，线程隔离的有PC程序计数器、虚拟机栈、本地方法栈。如下图所示： 图2.JVM内存结构概览 程序计数器&emsp;CPU的寄存器中有一个指令寄存器IP(64位RIP,32位EIP,也称为程序计数器PC),存放下一条指令在内存中的地址。JVM内存结构中的PC可以理解为是CPU中的PC的抽象，指向的是内存中字节码指令的地址（可以简单理解为字节码指令的行号）。因为在多核CPU中，每个核跑一个线程，所以Java程序的多个线程可以同时运行，所以每个线程就需要各自的PC。如果是线程执行的是一个Java方法，那么PC记录的是指令的地址。如果是Native方法，则这个PC的值为空null。 Java虚拟机栈&emsp;同样的Java的虚拟机栈也可以理解为虚拟内存中栈的抽象。也是线程私有的，它们功能都是一样的，存储的是方法执行的栈帧（Stack Frame）。方法的调用和返回代表的就是虚拟机栈的入栈和出栈操作。栈顶就是当前线程正在执行的方法的栈帧。栈帧中存储的就是方法执行需要的一些信息，如局部变量表、操作数栈、方法出口等。 &emsp;局部变量表存放了编译器就知道了的各种基本数据类型（boolean,byte,char,short,int,float,long,double）、对象引用、returnAddress类型（指向一条字节码指令的地址）。可以把局部变量表理解为一个数组，其中long和double占用占用2个槽位（slot）,其余的都是占用1个槽位。32位虚拟机long和double用2个槽位存储数据，即使是64位的虚拟机，long和double也是2个槽位（1个槽位存储64位数据，另一个槽位为空）。 &emsp;局部变量表的大小在编译期就确定了，在运行时是不会改变其大小的。如果是对象方法的局部变量表，第一个slot是this指针，这也是为什么每个非静态方法里可以访问this的原因，静态方法则不存在this指针。然后是方法入参，然后是方法体中的局部变量。就是这样即使是我们自己，也可以很好判断局部变量表的大小。 &emsp;操作数栈就是字节码指令需要的操作数，在某些指令执行前需要提前将操作数压入操作数栈，比如iadd，则需要提前将两个整数压入操作数栈中。对应的指令是iload(从局部变量表指定位置将数据加载到操作数栈栈顶)。同样，操作数栈的大小在编译期就已经确定。 &emsp;返回地址，当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion) 。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。 &emsp;在这个虚拟机栈中可能会出现两个异常：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈动态扩展时申请不到足够的内存，就会抛出OutOfMemoryError异常。可以通过下方的代码进行测试 123456789101112131415161718192021222324/** * VM args: -Xss128k * */public class JavaVMStackSOF &#123; private int stackLength; public void stackLeak() &#123; stackLength ++ ; stackLeak(); &#125; public static void main(String[] args)&#123; JavaVMStackSOF javaVMStackSOF = new JavaVMStackSOF(); try &#123; javaVMStackSOF.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println("stack length:"+javaVMStackSOF.stackLength); throw e; &#125; &#125;&#125; &emsp;扩展，当后面学习了class文件，字节码指令后，可以使用命令javap -v -p classfile反解析出字节码,查看局部变量表的大小，以及每个槽位存储的是什么。如下代码所示： 123456789public static void staticMethod(String str)&#123; System.out.println("static method "+str); &#125;public int virtualMethod(String word, Integer i)&#123; System.out.println(word); return i; &#125; 对应的字节码: 123456789101112131415161718192021222324252627282930313233343536public int virtualMethod(java.lang.String, java.lang.Integer); descriptor: (Ljava/lang/String;Ljava/lang/Integer;)I flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=3 0: getstatic #11 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_1 4: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 7: aload_2 8: invokevirtual #16 // Method java/lang/Integer.intValue:()I 11: ireturn LineNumberTable: line 29: 0 line 30: 7 LocalVariableTable: Start Length Slot Name Signature 0 12 0 this Lpractice/bytecode/BytecodeCommand; 0 12 1 word Ljava/lang/String; 0 12 2 i Ljava/lang/Integer;public static void staticMethod(java.lang.String); descriptor: (Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #11 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 7: return LineNumberTable: line 41: 0 line 42: 7 LocalVariableTable: Start Length Slot Name Signature 0 8 0 str Ljava/lang/String; 本地方法栈&emsp;这个栈与虚拟机栈结构类似，是Native方法执行时的栈帧。不同的虚拟机有不同的实现，Hotspot虚拟机是将两者合二为一的。 Java堆&emsp;在C中，堆是动态内存区域，由malloc()函数分配内存，Hotspot虚拟机是由C++实现的，那么对象创建可能是由C++ new操作符实现的。具体的可能要看虚拟机源码才能清楚，总之，先不管是由什么实现，先理解Java虚拟机的中的堆。Java堆可以说是虚拟机中最大的一块内存了，它的唯一目的就是存放实例对象的数据，通过new出的对象和数组一般都是放到堆中的。随着JIT编译器的发展和逃逸分析技术的成熟，栈上分配、标量替换优化技术使得不再完全是堆上分配。栈上分配c语言有个函数alloca()就是进行栈上分配内存。标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间，这样就加快了数据的访问。 &emsp;Java堆是垃圾收集器管理的主要区域，这里有大量对象朝生夕死，也有老顽固存活下来。垃圾收集器基本上是分代收集算法，所以垃圾收集器把Java堆分为 年轻代{eden区、survivor区[survivor from(s0)、survicor to(s1)]}、老年代。从内存分配角度来看，为了解决并发分配对象的效率，线程共享的堆中又各自有各自的TLAB分配缓冲区（Thread Local Allocation Buffer）使用-XX:+/-UseTLAB开启关闭（默认开启）。如果不使用TLAB,那么线程在请求内存的时候就会竞争，虽然不是用synchronized同步锁住整个区域，而是使用的CAS（Compare And Swap比较并交换）加失败重试(即轻量级锁)，但仍然会存在竞争而消耗性能。而TLAB的话，线程隔离，平常分配不需要同步，只有TLAB不够分配了，申请新的TLAB才会在整个区域重新申请内存而使用同步CAS去操作。 图3.堆内存分代结构 &emsp;Java堆内存大小由Xms初始大小（memory start）,Xmx最大内存(memory max)这两个参数控制。形成可扩展的堆内存。如果申请内存时不能再扩展了，就会抛出OutOfMemoryError异常。以下是测试代码： 123456789101112131415import java.util.ArrayList;import java.util.List;public class HeapOOM &#123; public static void main(String[] args)&#123; String test = "heapOOm"; List&lt;String&gt; list = new ArrayList&lt;&gt;(100000); while (true)&#123; String str = test + test; list.add(str.intern()); &#125; &#125;&#125; 123456789Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:261) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) at java.util.ArrayList.add(ArrayList.java:458) at practice.heapOOM.HeapOOM.main(HeapOOM.java:13) &emsp;一般来说，引起堆OOM的，要么是系统长时间运行，存在内存泄漏leak,积少成多最终导致垃圾收集器无法回收这些没用的对象数据，要么是本身配置的内存就不够，动态扩展时申请不到内存，出现内存溢出。 方法区&emsp;从名字就可以看出来，这个区域主要是存储方法的。class文件的字节码经过类加载后就进入了方法区变成class对象，所以方法区存储的是类的相关信息（如类名、访问修饰符、运行时常量池、字段描述、方法描述等），即时编译器JIT编译后的代码等数据。GC垃圾收集器在1.7及以前把该区域叫做永久代（和堆是逻辑上连续的），1.8后叫做元空间metaspace，使用Native Memory来分配空间，这样元空间的大小就由32/64位系统的虚拟内存可用大小决定，但也可用MaxMetaspaceSize参数限制。元空间是Hotspot对方法区的具体实现。并且JDK1.7及以后把在永久代的字符串常量池移到堆内存中了。 &emsp;要测试方法区的OOM,基本思路是在运行时产生大量的类去填满方法区，直到溢出。所以，我们可以使用CGLib直接操作字节码运行时生成大量的动态类。示例代码如下： 123456789101112131415161718192021222324252627282930313233import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * VM args: -XX:MaxMetaspaceSize=10m * */public class MethodAreaClassOOM &#123; static class OOMObject&#123;&#125; public static void main(String[] args) &#123; while(true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125;&#125; 12345Caused by: java.lang.OutOfMemoryError: Metaspace at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:760) ... 11 more 运行时常量池&emsp;Class文件除了类的版本、字段、方法、接口等信息外，还有一项信息是常量池（Constants Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区每个类的运行时常量池，当然也会把翻译出的直接引用存储在运行时常量池中。 &emsp;扩展：比较了解 class文件常量池，运行时常量池，字符串常量池 与类加载过程的关系（待总结） 直接内存&emsp;直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用，而且也可能导致OOM异常出现。在JDK1.4中新加入的NIO(New Input/Output)类，引入了一种基于通道channel的与缓冲区buffer的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样显著提升了性能，因为避免了在堆内存和Native堆中来回复制数据。 &emsp;虽然直接内存的分配不会收到Java堆的大小限制，但是会收到本机总物理内存或虚拟内存地址空间大小限制。如果配置Xmx时忽略了这部分直接内存，导致运行时加起来超过了限制，动态扩展时就会出现OOM异常。可通过-XX:MaxDirectMemorySize指定直接内存的大小。如果不指定，默认与-Xmx一样大。以下是测试OOM代码，代码越过DirectByteBuffer类，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是只有rt.jar中的类才能使用Unsafe）。 1234567891011121314151617181920/** * VMargs: -XX:DirectMemorySize=10M * */public class DirectMemoryOOM &#123; private static final int ONE_MB = 1024 * 1024; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; Field field = Unsafe.class.getDeclaredField("theUnsafe"); field.setAccessible(true); Unsafe unsafe = (Unsafe) field.get(null); while (true) &#123; unsafe.allocateMemory(ONE_MB); &#125; &#125;&#125; 1234Exception in thread "main" java.lang.OutOfMemoryError at sun.misc.Unsafe.allocateMemory(Native Method) at practice.directMemoryOOM.DirectMemoryOOM.main(DirectMemoryOOM.java:21)]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM内存结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
