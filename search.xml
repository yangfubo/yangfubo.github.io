<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring系列之事务抽象与管理]]></title>
    <url>%2F2019%2F11%2F19%2FSpring%E7%B3%BB%E5%88%97%E4%B9%8B%E4%BA%8B%E5%8A%A1%E6%8A%BD%E8%B1%A1%E4%B8%8E%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务是大家非常熟悉的，后端开发必须得理解事务原理，而作为Java开发，Spring框架也是必须熟悉的，那么Spring是如何表示事务，如何管理事务的呢？那就是这篇文章需要搞清楚的。事务的ACID特性 原子性 Atomicity 要么全部执行成功，要么全部失败。 一致性 Consistency 假设A,B之间转账，他们的总和是不变的。这种状态是一致的。 隔离性 Isolation 事务之间相互隔离，防止脏读，不可重复读，幻读等问题。 持久性 Durability 事务一旦提交，那么执行结果就持久化了，即使这时数据库崩溃，也可以恢复数据。 事务隔离级别 读未提交 read uncommited 读已提交 read commited 可重复读 repeatable read 序列化 serializable 标准SQL的事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交 是 是 是 读已提交 否 是 是 可重复读 否 否 是 序列化 否 否 否 MySQL的事务隔离级别 事务隔离级别 脏读 不可重复读 幻读 读未提交 是 是 是 读已提交 否 是 是 可重复读 否 否 否 序列化 否 否 否 MySQL的事务隔离级别与标准SQL有点不同，在可重复读隔离级别下，它也能防止幻读。它是通过MVCC防止脏读，不可重复读，gap间隙锁防止幻读，详情可以去了解多版本并发控制MVCC与加锁机制。 事务相关MySQL命令 关闭自动提交 set autocommit = 0; 设置只读事务 set transaction read only; 开启事务 begin 开启事务，还可以start transaction;还有start transaction with consistent snapshot;开启事务并创建一致性视图（只在可重复读隔离级别下），详细可去了解MySQL的多版本并发控制MVCC。 提交 commit 当事务中的sql全部执行成功后，便可commit;此处可以去了解redo log与binlog的“两阶段提交”过程。 回滚 rollback 当执行出错，或业务逻辑出错，事务需要回滚。此处可以去了解undo log回滚日志。 Spring事务抽象首先，我们来看下它主要的接口和类,主要有TransactionDefinition,TransactionStatus,PlatformTransactionManager,TransactionInterceptor,TransactionSynchronizationManager,TransactionInfo(definition+status+tm)等等。 TransactionDefinition 事务定义 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public interface TransactionDefinition &#123; // 若当前线程不存在事务中, 则开启一个事务, 若当前存在事务, 则加入其中 int PROPAGATION_REQUIRED = 0; // 若当前存在事务, 则加入到事务中, 若不存在, 则以非事务的方式运行 int PROPAGATION_SUPPORTS = 1; // 若有事务, 则用当前的事务, 若没有, 则直接抛出异常 int PROPAGATION_MANDATORY = 2; // 若当前存在事务, 则挂起事务, 若当前不存在事务, 则开启一个新事务运行 int PROPAGATION_REQUIRES_NEW = 3; // 不支持以事务的方式运行, 若当前存在事务, 则将当前的事务挂起 int PROPAGATION_NOT_SUPPORTED = 4; // 不支持事务, 若当前线程含有事务, 则直接抛出异常 int PROPAGATION_NEVER = 5; // 这个时在原来的事务中通过 savepoint 的方式 开启一个局部事务 int PROPAGATION_NESTED = 6; // 默认隔离级别 int ISOLATION_DEFAULT = -1; // read_uncommitted 读未提交级别 int ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED; // READ_COMMITTED 读已提交级别 int ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED; // REPEATABLE_READ 可重复读级别 int ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ; // SERIALIZABLE 序列化级别 int ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE; // 默认超时时间 int TIMEOUT_DEFAULT = -1; // 获取传播行为 int getPropagationBehavior(); // 获取隔离级别 int getIsolationLevel(); // 获取超时时间 int getTimeout(); // 事务是否是只读模式 boolean isReadOnly(); // 返回事务的名字 String getName();&#125; DefaultTransactionDefinition的属性：传播行为，隔离级别，超时回滚，只读事务，事务名称 12345678910// 传播行为private int propagationBehavior = PROPAGATION_REQUIRED;// 隔离级别private int isolationLevel = ISOLATION_DEFAULT;// 超时回滚private int timeout = TIMEOUT_DEFAULT;// 只读事务private boolean readOnly = false;// 事务名称private String name; @Transactional注解就包含这些配置,在事务拦截器中会解析为definition,下面源码分析时就会看到。 TransactionStatus 事务状态 事务状态维护这一个事务开始到结束的一些状态，在默认的实现类DefaultTransactionStatus中包含比如事务对象（包含连接），是否已完成，回滚标志，保存点，挂起事务等信息。 DefaultTransactionStatus的属性： 12345678910111213141516171819// 事务连接器, 比如 DataSourceTransactionManager 中的 DataSourceTransactionObjectprivate final Object transaction;// 是否是新事务private final boolean newTransaction;// 是否开启 事务同步器 &lt;- 其实就是在 TransactionSynchronousManager 中注册属性信息private final boolean newSynchronization;// 这个事务是否是 readOnlyprivate final boolean readOnly;// suspend 的上个事务的信息, suspendedResources 可能是 nullprivate final Object suspendedResources;// -------AbstractTransactionStatus-------// 是否只能回滚private boolean rollbackOnly = false;// 是否已完成private boolean completed = false;// savepoint保存点private Object savepoint; PlatformTransactionManager 平台事务管理器 123456789public interface PlatformTransactionManager &#123; // 获取事务 TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; // 提交 void commit(TransactionStatus status) throws TransactionException; // 回滚 void rollback(TransactionStatus status) throws TransactionException;&#125; 有多个实现类，一般都是使用基于数据源DataSource的DataSourceTransactionManager。 TransactionInfo 事务信息封装 123456789101112131415161718protected final class TransactionInfo &#123; // 事务管理器 private final PlatformTransactionManager transactionManager; // 事务定义definition private final TransactionAttribute transactionAttribute; // 类名+方法名 private final String joinpointIdentification; // 事务状态 private TransactionStatus transactionStatus; // 老事务，可能为空 private TransactionInfo oldTransactionInfo;&#125; 成功开启一个事务后，会将status和definition封装成txInfo并线程隔离保存在TransactionAspectSupport:ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder; 声明式事务 Spring提供了两种事务使用方式，编程式事务和声明式事务，一般我们使用基于注解的AOP实现—声明式事务，即@Transactional注解的方法或类会被代理。AOP与业务代码无侵入，只需要关心业务实现逻辑上，不用咱们手动开始，回滚事务。下面将进行详细的原理源码分析，贴上来的代码是我选择重要逻辑，精简的，带注释说明的， TransactionInterceptor源码分析TransactionIntercepter事务拦截，继承了TransactionAspectSupport,就是一个around的增强，主要逻辑在方法invokeWithinTransaction中。 invokeWithinTransaction方法获取事务定义属性txAttr，事务管理器tm,创建事务，执行目标方法，如果抛出异常则进行异常处理（回滚或提交），否则进行提交处理（提交或回滚） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass, final InvocationCallback invocation) throws Throwable &#123; // If the transaction attribute is null, the method is non-transactional. // @Transactional注解转换成TransactionAttribute（继承TransactionDefinition） // 获取到AnnotationTransactionAttributeSource：通过获取方法上的注解信息来获知 事务的属性, 解析主要由 SpringTransactionAnnotationParser 来进行 TransactionAttributeSource tas = getTransactionAttributeSource(); final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null); // 获取@Transactional中配置的transactionManager属性获取对应的beanName的对象或者设置的默认事务管理器， 都通过beanFactory获取，beanName或类型 final PlatformTransactionManager tm = determineTransactionManager(txAttr); final String joinpointIdentification = methodIdentification(method, targetClass, txAttr); /** * 这里区分不同类型的 PlatformTransactionManager 因为它们的调用方式不同 * 对 CallbackPreferringPlatformTransactionManager 来说, 需要回调函数来 * 实现事务的创建和提交 * 对于非 CallbackPreferringPlatformTransactionManager 来说, 不需要通过 * 回调函数来实现事务的创建和提交 * 像 DataSourceTransactionManager 就不是 CallbackPreferringPlatformTransactionManager * 不需要通过回调的方式来使用 */ if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123; // Standard transaction demarcation with getTransaction and commit/rollback calls. // 如果必要创建事务（因为此时可能是嵌套事务，则会使用已存在的事务） TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try &#123; // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. // 目标方法调用,沿着拦截器链进行下去 retVal = invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; // target invocation exception // 异常回滚，rollback操作，如果此异常不回滚，则提交（@transactional的rollbackFor配置需要回滚的异常） completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; finally &#123; // 与线程绑定的TransactionInfo 设置为 oldTransactionInfo cleanupTransactionInfo(txInfo); &#125; // 无异常，如果不是rollbackOnly,则commit操作， commitTransactionAfterReturning(txInfo); return retVal; &#125; else&#123; // CallbackPreferringPlatformTransactionManager &#125;&#125; 创建事务createTransactionIfNecessary获取连接，并将事务定义和状态封装到TransactionInfo，通过TransactionAspectSupport绑定到线程 1234567891011121314protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm, @Nullable TransactionAttribute txAttr, final String joinpointIdentification) &#123; TransactionStatus status = null; if (txAttr != null) &#123; if (tm != null) &#123; // PlatformTransactionManager接口调用,实际调用AbstractPlatformTransactionManager.getTransaction,它里面是策略模式和模板方法设计模式的运用 status = tm.getTransaction(txAttr); &#125; &#125; // 将definition和status封装到transactionInfo并绑定到线程中 TransactionAspectSupport: ThreadLocal&lt;TransactionInfo&gt; transactionInfoHolder return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);&#125; 事务连接获取tm.getTransaction主要包含获取连接，将连接和其他事务信息通过事务同步器TransactionSynchronizationManager绑定到线程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException &#123; // 获取事务，有子类实现，模板方法 Object transaction = doGetTransaction(); // 如果已经存在事务 if (isExistingTransaction(transaction)) &#123; // Existing transaction found -&gt; check propagation behavior to find out how to behave. // 方法内根据传播行为不同，执行不同的逻辑（策略模式），如果是required_new ,则是新建事务连接;如果是nested,则是使用savePoint return handleExistingTransaction(definition, transaction, debugEnabled); &#125; // No existing transaction found -&gt; check propagation behavior to find out how to proceed. if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123; throw new IllegalTransactionStateException( &quot;No existing transaction found for transaction marked with propagation &apos;mandatory&apos;&quot;); &#125; // 不存在事务 else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; // 传播行为是required/requires_new/nested则会新建事务（策略模式），默认配置是PROPAGATION_REQUIRED SuspendedResourcesHolder suspendedResources = suspend(null); try &#123; boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); // 创建事务状态 DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); // 创建事务连接，dataSource.getConnection，连接保存到TransactionSynchronizationManager线程同步管理器的ThreadLocal&lt;Map&lt;DataSource,&gt;&gt; doBegin(transaction, definition); // 将事务的一些属性绑定到线程，TransactionSynchronizationManager线程同步管理器，内部有许多ThreadLocal保存信息，如事务连接资源，readOnly是否只读等 // MyBatis会在获取事务连接时中通过TransactionSynchronizationManager获取，MyBatis源码入口SpringManagedTransactionFactory prepareSynchronization(status, definition); return status; &#125; catch (RuntimeException | Error ex) &#123; resume(null, suspendedResources); throw ex; &#125; &#125; else &#123; // Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization. if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123; logger.warn(&quot;Custom isolation level specified but no actual transaction initiated; &quot; + &quot;isolation level will effectively be ignored: &quot; + definition); &#125; boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null); &#125;&#125; 提交或回滚提交回滚的逻辑比较复杂，事务有嵌套关系，整个过程事务状态的转变有点复杂，比较难debug，我尽可能得按自己的理解画出了事务的过程，可能有错误欢迎指正，在后续的学习，应用过程中再继续修订。注：内外层事务使用的是required传播行为（有事务则用外层事务，无事务则新建）。 再回忆下事务处理的一个大概流程，如下伪代码： 123456789101112131415161718protected Object invokeWithinTransaction(...) throws Throwable &#123; // 获取事务定义，事务管理器tm // 创建事务 createTransactionIfNecessary; try&#123; // 调用目标方法 retVal = invoke; &#125;catch(ex)&#123; // 方法内根据配置的回滚异常决定是提交还是回滚 completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; // 无异常，提交，但也会根据手动回滚设置的/内层事务回滚设置的rollbackOnly进行回滚 commitTransactionAfterReturning(txInfo); return retVal;&#125; 提交或回滚代码中一般都是commit-&gt;processCommit-doCommit,rollback-&gt;processRollback-&gt;doRollback 无异常，事务提交 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586public final void commit(TransactionStatus status) throws TransactionException &#123; if (status.isCompleted()) &#123; throw new IllegalTransactionStateException( &quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;); &#125; DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status; if (defStatus.isLocalRollbackOnly()) &#123; if (defStatus.isDebug()) &#123; logger.debug(&quot;Transactional code has requested rollback&quot;); &#125; // 业务代码中手动设置回滚时 TransactionAspectSupport.currentTransactionStauts().setRollbackOnly(); processRollback(defStatus, false); return; &#125; if (!shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123; if (defStatus.isDebug()) &#123; logger.debug(&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;); &#125; // 内层事务异常（设置了rollbackOnly）但在主事务中被catch了，未继续抛出异常或手动设置回滚 processRollback(defStatus, true); return; &#125; // 处理提交 processCommit(defStatus);&#125;private void processCommit(DefaultTransactionStatus status) throws TransactionException &#123; try &#123; boolean beforeCompletionInvoked = false; try &#123; boolean unexpectedRollback = false; // 一些事务提交前的触发器调用 prepareForCommit(status); triggerBeforeCommit(status); triggerBeforeCompletion(status); beforeCompletionInvoked = true; if (status.hasSavepoint()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Releasing transaction savepoint&quot;); &#125; unexpectedRollback = status.isGlobalRollbackOnly(); // 释放保存点 status.releaseHeldSavepoint(); &#125; else if (status.isNewTransaction()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Initiating transaction commit&quot;); &#125; unexpectedRollback = status.isGlobalRollbackOnly(); // 是外层事务（新事务）,真正提交,connection.commit() doCommit(status); &#125; else if (isFailEarlyOnGlobalRollbackOnly()) &#123; unexpectedRollback = status.isGlobalRollbackOnly(); &#125; // Throw UnexpectedRollbackException if we have a global rollback-only // marker but still didn&apos;t get a corresponding exception from commit. if (unexpectedRollback) &#123; throw new UnexpectedRollbackException( &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;); &#125; &#125; // 去除一些catch异常等非主要代码 // Trigger afterCommit callbacks, with an exception thrown there // propagated to callers but the transaction still considered as committed. try &#123; triggerAfterCommit(status); &#125; finally &#123; triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED); &#125; &#125; finally &#123; // 释放事务资源，恢复上一个挂起的事务等 cleanupAfterCompletion(status); &#125;&#125; 异常，事务回滚 发生异常情况下，如果是我们配置的异常，则回滚处理，否则调用提交处理。处理回滚如果是外层事务，则真正回滚，如果是内层事务，则是设置rollbackOnly 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) &#123; if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) &#123; if (txInfo.transactionAttribute != null &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123; // 在@transactional注解配置的rollbackFor异常 如rollbackFor=Exception.calss try &#123; txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus()); &#125; // 省略catch &#125; else &#123; // We don&apos;t roll back on this exception. // Will still roll back if TransactionStatus.isRollbackOnly() is true. // 在设置了rollbackOnly还是要回滚 try &#123; txInfo.getTransactionManager().commit(txInfo.getTransactionStatus()); &#125; // 省略catch &#125; &#125;&#125;private void processRollback(DefaultTransactionStatus status, boolean unexpected) &#123; try &#123; boolean unexpectedRollback = unexpected; try &#123; triggerBeforeCompletion(status); if (status.hasSavepoint()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Rolling back transaction to savepoint&quot;); &#125; // 直接回滚到保存点 status.rollbackToHeldSavepoint(); &#125; else if (status.isNewTransaction()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Initiating transaction rollback&quot;); &#125; // 外层事务才真正回滚 connection.rollback() doRollback(status); &#125; else &#123; // Participating in larger transaction if (status.hasTransaction()) &#123; if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) &#123; if (status.isDebug()) &#123; logger.debug(&quot;Participating transaction failed - marking existing transaction as rollback-only&quot;); &#125; // 内层事务异常，仅仅设置全局回滚 doSetRollbackOnly(status); &#125; else &#123; if (status.isDebug()) &#123; logger.debug(&quot;Participating transaction failed - letting transaction originator decide on rollback&quot;); &#125; &#125; &#125; else &#123; logger.debug(&quot;Should roll back transaction but cannot - no transaction available&quot;); &#125; // Unexpected rollback only matters here if we&apos;re asked to fail early if (!isFailEarlyOnGlobalRollbackOnly()) &#123; unexpectedRollback = false; &#125; &#125; &#125; catch (RuntimeException | Error ex) &#123; triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN); throw ex; &#125; triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK); // Raise UnexpectedRollbackException if we had a global rollback-only marker // unexpected传入为true,外层事务在提交时发现全局回滚标记为true则调用processRollback(stauts,true),其他情况传入的都是false if (unexpectedRollback) &#123; throw new UnexpectedRollbackException( &quot;Transaction rolled back because it has been marked as rollback-only&quot;); &#125; &#125; finally &#123; // 释放事务资源，恢复上一个挂起的事务等 cleanupAfterCompletion(status); &#125;&#125; 示例代码分析下面的代码默认都采用required传播行为， 1234567891011121314151617181920212223// 不建议这种catch内层事务异常，而不手动回滚或继续抛异常的，这样别人调你接口根本不知道是什么出错了，最好抛出一个说明原因的异常。// 执行前（&quot;zhangsan&quot;,18）@Transactional(rollbackFor = Exception.class) public int innerTxExIgnore(String username, int age) throws Exception &#123; userDao.updateAge(username, age); // (&quot;zhangsan&quot;,20) try &#123; // dao方法内会抛出异常 userDao.updateAgeEx(username,age+1); &#125; catch (Exception e) &#123; log.info(&quot;innerTxExIgnore.忽略异常&quot;); &#125; // (&quot;zhangsan&quot;,20) userDao.updateName(username, &quot;test&quot;); // (&quot;zhangsan&quot;,&quot;test&quot;,20) log.info(&quot;innerTxExIgnore.ignore更新后：&#123;&#125;&quot;,userDao.get(username)); log.info(&quot;innerTxExIgnore.异常后仍执行其他事务&quot;); // 最终外层事务提交时，会因为全局rollbackOnly回滚所有sql并抛出异常marked as roll-back only return 1; &#125;// 执行后（&quot;zhangsan&quot;,18） 1234567891011121314151617// 内层事务异常被catch,手动设置回滚还算正确// 执行前（&quot;zhangsan&quot;,18）@Transactional(rollbackFor = Exception.class) public int innerTxExSetRoll(String username, int age) throws Exception &#123; userDao.updateAge(username, age); // (&quot;zhangsan&quot;,20) try &#123; userDao.updateAgeEx(username,age+1); &#125; catch (Exception e) &#123; log.info(&quot;innerTxExSetRoll.手动设置rollbackOnly&quot;); TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); &#125; // (&quot;zhangsan&quot;,20) return 1; &#125;// 执行后(&quot;zhangsan&quot;,18) 1234567891011121314// 内层事务异常被catch,继续向上抛出此异常（或转换为其他异常）// 最好这样做，这样后面的代码就不会再执行，执行了也要被回滚，除非后面的是新启一个事务（requires_new）@Transactional(rollbackFor = Exception.class) public int innerTxExSetRoll(String username, int age) throws Exception &#123; userDao.updateAge(username, age); try &#123; userDao.updateAgeEx(username,age+1); &#125; catch (Exception e) &#123; // 异常处理后 继续向上抛出该异常 throw e; &#125; return 1; &#125; 123456789101112131415@Transactional(propagation = Propagation.REQUIRES_NEW,rollbackFor = Exception.class) public void newTx(String username) throws Exception &#123; userDao.updateName(username, &quot;test&quot;); throw new Exception(); &#125;@Transactional(rollbackFor = Exception.class)public void innerTxNotWork(String username, int age) throws Exception &#123; userDao.updateAge(username, age); // 因为是直接调用的目标方法，而不是代理后的，所以下面方法不是新事务 newTx(username); //((UserService) (AopContext.currentProxy())).newTx(username);正确用法 // 或者将UserService注入 或者用spring工具类getBean(beanName)获取实例 &#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>spring事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RocketMQ源码分析之启动Producer]]></title>
    <url>%2F2019%2F09%2F29%2FRocketMQ%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%90%AF%E5%8A%A8Producer%2F</url>
    <content type="text"><![CDATA[&emsp;最近在学习消息中间件，最后选择了RocketMQ来学习和应用。因为RocketMQ作为阿里开源出来的消息中间件（支持国产），经受了双11和各种大促活动的考验，是一个高可用，可扩展的成熟MQ。另外一点是它是JAVA语言写的，我是Java程序员，如果需要修改源码，那么学习成本也低很多。毕竟其他消息中间件大多都是其他语言写的，不好研究源码。事实证明，即使是我这样只有1年工作经验的菜鸟，也能看懂它的代码，从中学到点东西。&emsp;在看了官方文档的Quick Start,几个example后，发现客户端API很简单。发布订阅模型和消息队列模型；普通消息，有序消息，事务消息；集群消费，广播消费；异步处理，系统解耦，流量削峰；producer同步/异步发送，broker同步或异步刷盘，master-slave复制等保障high-availible,不管是producer,nameserver,broker还是consumer都可以水平扩容。以RocketMQ的源码来学习分布式集群、高可用、可扩展的中间件应该是不错的选择。如果我上面提到的这些概念不清楚的话，建议去看官方文档，以及RocketMQ3.+的相关文档； RocketMQ官方文档 http://rocketmq.apache.org/docs/quick-start/ RocketMQ3原理简介 http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408165024/RocketMQ_design.pdf RocketMQ3用户指南 http://gd-rus-public.cn-hangzhou.oss-pub.aliyun-inc.com/attachment/201604/08/20160408164726/RocketMQ_userguide.pdf &emsp;对于如何看源码，无非是将源码clone下来，查看源码中的单元测试，从单元测试入手，打断点，根据代码逻辑，画出类图，时序图，流程图等来帮助理解。不然看了等于没看。刚开始看的时候不要过多陷入细节，能够明白主要的流程，主要的功能点在什么地方和有哪些设计上的亮点等。源码版本4.5.2。 &emsp;查看client模块中DefaultMQProducerTest测试类，里面有很多测试方法,如下所示 init() terminate() testSendMessage_ZeroMessage() testSendMessage_NoNameSrv() testSendMessage_NoRoute() testSendMessageSync_Success() testSendMessageSync_WithBodyCompressed() testSendMessageAsync_Success() testSendMessageAsync() testSendMessageAsync_BodyCompressed() testSendMessageSync_SuccessWithHook() testSetCallbackExecutor() &emsp;init()方法是其他测试的方法基础，要先初始化一个producer出来，所以，就先分析Producer的参数设置，和start()过程。通过这个过程，来了解客户端各个类之间的关系以及启动了什么服务。主要的类关系如下图所示： &emsp;首先查看DefaultMQProducer类，它实现了MQProducer用户API接口，继承了ClientConfig客户端公共参数配置类，除了继承公共配置，DefaultMQProducer还自己定义了其他配置如 producerGroup 生产者组名称 defaultTopicQueueNums 默认的主题有多少个队列 sendMsgTimeout 发送消息超时 compressMsgBodyOverHowmuch 消息压缩 retryTimesWhenSendFailed 同步发送失败重试次数 retryTimesWhenSendAsyncFailed 异步发送失败重试次数 retryAnotherBrokerWhenNotStoreOK broker存储失败尝试另一个broker maxMessageSize 最大消息大小 &amp;emsp这里的DefaultMQProducer应该是门面模式的思想，向用户 隐藏具体实现的细节，让用户看到的就是一个简单的接口，你会看到DefaultMQProducer里就是调用相应DefaultMQProducerImpl的方法，，后面各个组件的配合实现都隐藏掉。就像你去咖啡店点一杯咖啡，你只需要告诉营业员要一杯咖啡，咖啡的研磨，冲泡，然后再服务员端上来的过程你都不需要了解并参与。但是DefaultMQProducer继承公共配置类并且自身也加了其他配置参数这样的实现方式我感觉不是很优雅，应该将配置类完全抽离出去，由一个类来统一管理。像Mybatis的Configuration和Spring的Environment等。在后面的DefaultMQProducerImpl中又引用了defaultMQProducer，但实际上大多数只是把它当做获取配置的接口而已，所以这样会有点让人困惑。 接下来看DefaultMQProducerImpl类，它是客户端Producer主要的实现逻辑,debug到start()方法，看到里面是根据状态，执行不同的代码。我们现在处于CREATE_JUST状态，在这里面初始化mQClientFactory（MQClientInstance类实例），通过MQClinetManager的单例中的factoryTable（ConcurrentMap&lt;String/* clientId /, MQClientInstance&gt;）来管理MQClientInstance，这样就不会重复创建相同的MQClientInstance，有点类似于Spring的BeanFactory。clientId = IP@instanceName,所以这里只要定义不同的instanceName就可以在一个Java进程中开启多个MQClientInstance。创建完MQClientInstance后，调用MQClinetInstance.registerProducer（producerGourp,producerImpl）注册producerImpl,进入这个方法，原来MQClientInstance使用ConcurrentMap&lt;String/ group */, MQProducerInner&gt;来管理DefaultMQProducerImpl(实现了MQProducerInner),大概浏览其他属性，发现还管理了consumer和adminExt。所以这时就可以明白MQClientInstance是客户端的真正实现，管理producer,consumer,各种service。注册完后，继续向下debug,到mQClientFactory.start(),这里面的初始化，也是不同状态的switch。这个方法里初始化了很多服务，如mQClientAPIImpl（由netty实现，远程命令实现），startScheduledTask（）启动各种定时任务（如定时从nameServer获取topic路由，与broker的心跳等），pullMessageService，rebalanceService等服务。到了这里整个start过程就基本结束了，producer就开始运行了。看文字描述可能有点混乱，还是画个时序图吧，如下图所示，可能图画的也不标准…. &emsp;总之呢，看完整个初始化过程，你会对客户端的类关系有个大概了解，有些什么服务，看到最后是由NettyRemotingClient实现的与服务器的通信，看来又要去了解一个新的开源框架了Netty了。当然具体每个服务是怎么实现的，以后又需要再继续研究吧。]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>消息中间件 RocketMQ Producer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础架构之一条select语句是如何执行的]]></title>
    <url>%2F2019%2F09%2F25%2FMySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%E4%B9%8B%E4%B8%80%E6%9D%A1select%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84%2F</url>
    <content type="text"><![CDATA[&emsp;作为程序员，除了要精通一门高级编程语言外，还必须熟悉数据库（MySQL/Oracle等）。平常我们只要会写SQL,懂点索引能加速查询,对于初级开发也就够了。但是如果只会输入一条语句，得到输出结果。对MySQL的原理一知半解，那么在发生问题的时候，就不知道问题出在哪。要想往高级工程师进阶，就得去理解MySQL的内部原理，底层细节。但是我不想这么早就扎入MySQL的源码中。对于我这个初入茅庐的菜鸟程序员，还是在以后的开发中，根据实际问题再去深入研究。这篇笔记主要记录我对MySQL的基础架构的理解，好吧，下面开始。 &emsp;直接贴上MySQL的组件图，那么我们就来讲讲这个图。 客户端首先，客户端就是我们程序员主要工作的地方，你写的Java代码就会调用MySQL提供的Java客户端API。一般客户端开发框架会封装一个连接池，管理复用MySQL的连接。而MySQL可大致分为Server层和存储引擎层两部分。假设我们执行这样一条SQL,select * from t where id = 1;来分析分析它的执行过程，以及各个组件都有什么作用。 1.连接器 连接管理，每个客户端连接在服务端都会对应与一个线程，连接器同样也是线程池，客户端连接断开了，不会关闭线程，而是等待处理下一个连接； 权限验证，将其权限信息读入内存，验证账户和密码的正确性，下面的组件还会用到这部分权限信息。 &emsp;顺带一提查询缓存，根据SQL语句查询是否有缓存，有则直接返回数据。这样看似可以加速查询，但对于读写频繁的业务，你对表上任一行做了更新操作，都会使得该表的缓存失效，假如一条读完下条写，缓存失效，下次又读，又进缓存，这样根本没有提高效率。所以根据业务需求，判断是否需要开启缓存吧，通常建议不使用。 2.分析器 进行词法分析，语法分析得到语法树，验证语法是否正确，比如根据语法树判断关键字是否正确。3.预处理器 此部分根据语法树中解析出的表、列信息，结合前面的权限信息判断用户是否对该表或列具有读/写权限等；4.优化器 主要负责优化SQL语句，包括重写查询、决定表的读取顺序，选择合适的索引（估计哪个索引执行快）等，据此生成最优的执行计划。对于上面那条SQL语句，会选择id主键索引。5.执行器 根据执行计划给出的指令，调用存储引擎的API,进行计算等。那么这个例子就是调用查询id=1的存储引擎接口。6.存储引擎 提供API,比如查询某个索引第一行的接口，查询某个索引条目（数据行）下一个条目的接口。这个例子就是遍历id主键索引树，返回给执行器id=1这一行。 存储数据，在内存中提供Buffer Pool,读写磁盘 &emsp;返回结果集，执行器查出数据后，数据由连接器中的当前线程传送回数据，并不是所有数据都查出来了一次性返回给客户端，而是查出数据就可以往连接里传送数据了。 参考资料： 《高性能MySQL 第三版》章节1.1、6.4 极客时间《MySQL实战45讲》–丁奇大佬，第一章《基础架构：一条SQL查询语句是如何执行的？》]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL基础架构 select语句</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[class文件常量池，运行时常量池，字符串常量池到底都是啥？]]></title>
    <url>%2F2019%2F09%2F25%2Fclass%E6%96%87%E4%BB%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%88%B0%E5%BA%95%E9%83%BD%E6%98%AF%E5%95%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[傻傻分不清楚&emsp;在看《深入理解Java虚拟机》的时候，在前面的内存结构章节中，方法区中有运行时常量池，在学class文件结构的时候，又发现有class文件常量池，然后呢，还有个全局的字符串常量池（String table）。在网上搜索他们的区别，也很少有能够讲的清楚的。当然，也并不是说我就讲的清楚了。我也只是把我自己的理解用文字记录下来。以便以后还是傻傻分不清。下面将会按照他们产生的顺序开始介绍。 class文件常量池(Constant Pool Table)&emsp;将源代码编译成class文件后，通过javap -v -p classfile 反解析出我们能看懂的字节码（你要是能看懂二进制当我没说）。你会看到，class文件里一开头就有很大一部分是Constant Pool。里面包含了各种字面量（Literal）和符号引用(Symbal References)。字面量和Java中的常量比较接近，如文本字符串、声明为final的常量值等，符号引用包括类和接口的全限定名，方法的名称和描述符，字段的名称和描述符。 &emsp;Java代码在javac编译的时候，不像C/C++那样有连接这一步骤，而是在虚拟机加载class文件的时候进行动态连接。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行时转换的话无法得到真正的内存入口地址（字段可以理解为字段的地址，方法为入口地址）。当虚拟机运行时，需要从class文件常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。这部分知识可以去了解类的加载过程。常量池里的内容具体是怎么定义的可以去看class文件结构的class文件常量池文章。 class文件常量池常量项结构.png 运行时常量池（Runtime Constant Pool）&emsp;前面我们已经知道class文件常量池是存放字面量和符号引用的了。那么运行时常量池是什么呢？&emsp;JVM在执行某个类的时候，会经过类的加载机制，将其加载，连接（验证、准备、解析），初始化。那么当类被加载到内存后，JVM就会将class文件常量池里的字面量和符号引用加载进运行时常量池，而且运行时常量池是一个类对应其自己的运行时常量池。在解析阶段可以将符号引用解析为直接引用（包括类或接口、字段、类方法、接口方法，invokeDynamic相关的符号引用），但存在Lazy的情况，虚拟机规范没有规定解析阶段发生的具体时间，只要求在执行anewarray,multianewarray,checkcast,new,getfield,getstatic,putfield,putstatic,instanceof,invokedynamic,invokeinterface,invokespecial,invokestatic,invokevirtual,ldc,ldc_w这16个用于操作符号引用的字节码指令之前，先对他们进行符号引用。从反解析出的字节码中可以看到，方法的调用比如invokevirtual后面会有符号引用在class文件常量池的索引。那么运行时就是拿这个符号引用的索引，去运行时常量池中获取解析后的直接引用。 字符串常量池（String Table）&emsp;字符串常量池，在JDK1.7将其从永久代移动到了java堆。它是全局共享的，所以也叫全局字符串常量池。如下代码在JDK1.6和JDK1.7中的OOM区域不同。 123456789static String str = "test";public static void main(String[] args)&#123; List&lt;String&gt; list = new LinkedList&lt;&gt;(); while(true)&#123; str = str+str; list.add(str.intern()); &#125;&#125; JDK1.6中是OutOfMemoryError: PermGen space JDK1.7及以上是OutOfMemoryError: Java heap space &emsp;全局字符串常量池可以理解为一个HashSet,里面存储的是String对象的引用,牢记是引用。真正的字符串其实是String类里的char[] value存储的字符数组。因为数组是引用类型，所以应该在java堆中存储着诸如”abc”=[‘a’,’b’,’c’]这样的数据。那么，是什么时候字符串字面量会加载进全局字符串常量池呢？下面我们就结合源代码、字节码、类加载、JVM内存结构，画个图来分析一波。源代码和字节码由于太多，我就完整地贴到笔记的最后面了。 3个常量池的关系图 &emsp;以上是我理解的3者的关系，首先经过类加载，在初始化阶段会调用类的初始化器对应于字节码中的static{}代码块(它会将静态属性或静态代码块在源码中的先后顺序进行组合到一个方法内)。&emsp;静态初始化方法内有ldc字节码指令（load constant?），这个指令的作用是：根据class文件常量池中的索引号（如下方的#2），去运行时常量池中寻找对应的常量，如果没有解析，则解析，将直接引用存入运行时常量池（以后就不用解析了），如果是整形则是把int值压入操作数栈供后面的Interge.valueOf(int)调用。如果是字符串，则会去全局字符串常量池中查找是否存在（类似equals）,存在则直接返回全局字符串常量池中的引用，不存在则在堆中创建一个String对象，把引用存入全局字符串常量池并返回其引用压入栈顶。 &emsp;class常量池中的常量加载到运行时常量池中，对它的解析resolve是lazy的。只有遇到ldc指令的时候才会去判断是否解析，没解析则解析。示例代码因为类加载最后是初始化，类静态属性的初始化赋值就会执行ldc指令，所以类加载完staticStr就已经解析了。但是如果是main方法中“str1 == str2”这样的字面量，只有在第一次运行到ldc命令的时候去真正解析。 123456789101112131415161718192021222324... ...Constant pool: #1 = Methodref #27.#57 // java/lang/Object."&lt;init&gt;":()V 对象默认无参初始化构造器 #2 = Integer 123456789 // 整形字面量 #3 = Methodref #58.#59 // java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 方法引用 #4 = String #60 // str 字符串字面量... ...static &#123;&#125;; //类初始化构造器&lt;clinit&gt; descriptor: ()V flags: ACC_STATIC Code: stack=2, locals=0, args_size=0 0: ldc #2 // int 123456789 从运行时常量池中获取int值并压入栈顶 2: invokestatic #3 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: putstatic #22 // Field staticNum:Ljava/lang/Integer; 8: ldc #4 // String str 从运行时常量池中获取直接引用并压入栈顶,获取过程中如果没解析过，会去全局字符串常量池中查找是否已驻留，无则在堆中新建String对象，其引用存入全局字符串常量池，并返回其引用 10: putstatic #13 // Field staticStr:Ljava/lang/String; 给staticStr静态属性赋值 13: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 16: ldc #25 // String run static init block code\n 18: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 21: return &emsp;重新整理下”str”这个字面量从class文件到main方法运行时的过程，类加载的加载阶段“str”从class文件常量池加载进运行时常量池，并在类初始化阶段(最先打印”run static init block code”)执行生成的初始化方法中第一次执行ldc命令，ldc命令检查到该字面量未解析，去全局字符串常量池中查找，也无对应引用，所以在堆中创建String对象，将其引用存入全局字符串常量池，返回这个引用，ldc命令将之加载到操作数栈顶，后面的putstatic将这个引用赋值给类静态属性staticStr；然后main方法里，另一个StaticString.str也是类初始化阶段执行ldc命令，运行时常量池中没解析，不过它在全局字符串常量池中发现有引用（StringConstantPool生成的），直接返回该引用，所以他们两个==为true;str1这个局部变量也使用ldc指令去本类运行时常量池中将字符串载入栈顶，发现已解析，返回直接引用压入栈顶；str2同理；str3调用构造器，查看源码发现，其实是将String对象的value属性赋值给新String对象；str4调用str3.intern(),该方法去全局字符串常量池中查找是否有等于str3（equals）的引用，发现有（前面类属性staticStr通过ldc产生的），返回全局字符串常量池中的引用。 &emsp;讲到这里，你已经基本掌握了class文件常量池、运行时常量池、全局字符串常量池中字符串的关系。但是其实还有JIT及时编译器优化（逃逸分析，栈上分配，标量替换，方法内联等）。不想再陷入过多的细节了，有兴趣的详细参考R大的文章https://www.iteye.com/blog/rednaxelafx-774673 本篇笔记参考的资料有：1.《深入理解Java虚拟机》2.https://www.zhihu.com/question/55994121/answer/1472960983.https://www.iteye.com/blog/rednaxelafx-774673 示例源码： 123456789101112131415161718192021222324252627282930public class StringConstantsPool &#123; public static Integer staticNum = 123456789; public static String staticStr = "str"; static &#123; System.out.println("run static init block code\n"); &#125; public static void main(String[] args) &#123; Integer localNum = 123456789; String str1 = "str"; String str2 = "str"; String str3 = new String("str"); String str4 = str3.intern(); System.out.println("static final str == str1 :" + (staticStr == str1)); System.out.println("str1 == str2 : " + (str1 == str2)); System.out.println("str1 == str3 : " + (str1 == str3)); System.out.println("str4 == str1 : " + (str4 == str1)); System.out.println("str4 == str3 : " + (str4 == str3)); System.out.println("staticNum == localNum : " + (staticNum == localNum)); System.out.println("StringConstantsPool.staticStr == StaticString.staticStr : " + (StringConstantsPool.staticStr == StaticString.staticStr)); &#125;&#125;public class StaticString &#123; public static String staticStr = "str";&#125; 示例字节码： javap - v -p clasfile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303Classfile /D:/WorkSpace/JavaPractice/target/classes/practice/bytecode/stringConstantsPool/StringConstantsPool.class Last modified 2019-9-26; size 2313 bytes MD5 checksum 5e0b6d05c2e567f5bbada19684e73854 Compiled from "StringConstantsPool.java"public class practice.bytecode.stringConstantsPool.StringConstantsPool minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #27.#57 // java/lang/Object."&lt;init&gt;":()V #2 = Integer 123456789 #3 = Methodref #58.#59 // java/lang/Integer.valueOf:(I)Ljava/lang/Integer; #4 = String #60 // str #5 = Class #61 // java/lang/String #6 = Methodref #5.#62 // java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V #7 = Methodref #5.#63 // java/lang/String.intern:()Ljava/lang/String; #8 = Fieldref #64.#65 // java/lang/System.out:Ljava/io/PrintStream; #9 = Class #66 // java/lang/StringBuilder #10 = Methodref #9.#57 // java/lang/StringBuilder."&lt;init&gt;":()V #11 = String #67 // static final str == str1 : #12 = Methodref #9.#68 // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #13 = Fieldref #26.#69 // practice/bytecode/stringConstantsPool/StringConstantsPool.staticStr:Ljava/lang/String; #14 = Methodref #9.#70 // java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder; #15 = Methodref #9.#71 // java/lang/StringBuilder.toString:()Ljava/lang/String; #16 = Methodref #72.#73 // java/io/PrintStream.println:(Ljava/lang/String;)V #17 = String #74 // str1 == str2 : #18 = String #75 // str1 == str3 : #19 = String #76 // str4 == str1 : #20 = String #77 // str4 == str3 : #21 = String #78 // staticNum == localNum : #22 = Fieldref #26.#79 // practice/bytecode/stringConstantsPool/StringConstantsPool.staticNum:Ljava/lang/Integer; #23 = String #80 // StringConstantsPool.staticStr == StaticString.staticStr : #24 = Fieldref #81.#69 // practice/bytecode/stringConstantsPool/StaticString.staticStr:Ljava/lang/String; #25 = String #82 // run static init block code\n #26 = Class #83 // practice/bytecode/stringConstantsPool/StringConstantsPool #27 = Class #84 // java/lang/Object #28 = Utf8 staticNum #29 = Utf8 Ljava/lang/Integer; #30 = Utf8 staticStr #31 = Utf8 Ljava/lang/String; #32 = Utf8 &lt;init&gt; #33 = Utf8 ()V #34 = Utf8 Code #35 = Utf8 LineNumberTable #36 = Utf8 LocalVariableTable #37 = Utf8 this #38 = Utf8 Lpractice/bytecode/stringConstantsPool/StringConstantsPool; #39 = Utf8 main #40 = Utf8 ([Ljava/lang/String;)V #41 = Utf8 args #42 = Utf8 [Ljava/lang/String; #43 = Utf8 localNum #44 = Utf8 str1 #45 = Utf8 str2 #46 = Utf8 str3 #47 = Utf8 str4 #48 = Utf8 StackMapTable #49 = Class #42 // "[Ljava/lang/String;" #50 = Class #85 // java/lang/Integer #51 = Class #61 // java/lang/String #52 = Class #86 // java/io/PrintStream #53 = Class #66 // java/lang/StringBuilder #54 = Utf8 &lt;clinit&gt; #55 = Utf8 SourceFile #56 = Utf8 StringConstantsPool.java #57 = NameAndType #32:#33 // "&lt;init&gt;":()V #58 = Class #85 // java/lang/Integer #59 = NameAndType #87:#88 // valueOf:(I)Ljava/lang/Integer; #60 = Utf8 str #61 = Utf8 java/lang/String #62 = NameAndType #32:#89 // "&lt;init&gt;":(Ljava/lang/String;)V #63 = NameAndType #90:#91 // intern:()Ljava/lang/String; #64 = Class #92 // java/lang/System #65 = NameAndType #93:#94 // out:Ljava/io/PrintStream; #66 = Utf8 java/lang/StringBuilder #67 = Utf8 static final str == str1 : #68 = NameAndType #95:#96 // append:(Ljava/lang/String;)Ljava/lang/StringBuilder; #69 = NameAndType #30:#31 // staticStr:Ljava/lang/String; #70 = NameAndType #95:#97 // append:(Z)Ljava/lang/StringBuilder; #71 = NameAndType #98:#91 // toString:()Ljava/lang/String; #72 = Class #86 // java/io/PrintStream #73 = NameAndType #99:#89 // println:(Ljava/lang/String;)V #74 = Utf8 str1 == str2 : #75 = Utf8 str1 == str3 : #76 = Utf8 str4 == str1 : #77 = Utf8 str4 == str3 : #78 = Utf8 staticNum == localNum : #79 = NameAndType #28:#29 // staticNum:Ljava/lang/Integer; #80 = Utf8 StringConstantsPool.staticStr == StaticString.staticStr : #81 = Class #100 // practice/bytecode/stringConstantsPool/StaticString #82 = Utf8 run static init block code\n #83 = Utf8 practice/bytecode/stringConstantsPool/StringConstantsPool #84 = Utf8 java/lang/Object #85 = Utf8 java/lang/Integer #86 = Utf8 java/io/PrintStream #87 = Utf8 valueOf #88 = Utf8 (I)Ljava/lang/Integer; #89 = Utf8 (Ljava/lang/String;)V #90 = Utf8 intern #91 = Utf8 ()Ljava/lang/String; #92 = Utf8 java/lang/System #93 = Utf8 out #94 = Utf8 Ljava/io/PrintStream; #95 = Utf8 append #96 = Utf8 (Ljava/lang/String;)Ljava/lang/StringBuilder; #97 = Utf8 (Z)Ljava/lang/StringBuilder; #98 = Utf8 toString #99 = Utf8 println #100 = Utf8 practice/bytecode/stringConstantsPool/StaticString&#123; public static java.lang.Integer staticNum; descriptor: Ljava/lang/Integer; flags: ACC_PUBLIC, ACC_STATIC public static java.lang.String staticStr; descriptor: Ljava/lang/String; flags: ACC_PUBLIC, ACC_STATIC public practice.bytecode.stringConstantsPool.StringConstantsPool(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return LineNumberTable: line 3: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lpractice/bytecode/stringConstantsPool/StringConstantsPool; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=4, locals=6, args_size=1 0: ldc #2 // int 123456789 2: invokestatic #3 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: astore_1 6: ldc #4 // String str 8: astore_2 9: ldc #4 // String str 11: astore_3 12: new #5 // class java/lang/String 15: dup 16: ldc #4 // String str 18: invokespecial #6 // Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V 21: astore 4 23: aload 4 25: invokevirtual #7 // Method java/lang/String.intern:()Ljava/lang/String; 28: astore 5 30: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 33: new #9 // class java/lang/StringBuilder 36: dup 37: invokespecial #10 // Method java/lang/StringBuilder."&lt;init&gt;":()V 40: ldc #11 // String static final str == str1 : 42: invokevirtual #12 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 45: getstatic #13 // Field staticStr:Ljava/lang/String; 48: aload_2 49: if_acmpne 56 52: iconst_1 53: goto 57 56: iconst_0 57: invokevirtual #14 // Method java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder; 60: invokevirtual #15 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 63: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 66: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 69: new #9 // class java/lang/StringBuilder 72: dup 73: invokespecial #10 // Method java/lang/StringBuilder."&lt;init&gt;":()V 76: ldc #17 // String str1 == str2 : 78: invokevirtual #12 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 81: aload_2 82: aload_3 83: if_acmpne 90 86: iconst_1 87: goto 91 90: iconst_0 91: invokevirtual #14 // Method java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder; 94: invokevirtual #15 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 97: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 100: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 103: new #9 // class java/lang/StringBuilder 106: dup 107: invokespecial #10 // Method java/lang/StringBuilder."&lt;init&gt;":()V 110: ldc #18 // String str1 == str3 : 112: invokevirtual #12 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 115: aload_2 116: aload 4 118: if_acmpne 125 121: iconst_1 122: goto 126 125: iconst_0 126: invokevirtual #14 // Method java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder; 129: invokevirtual #15 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 132: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 135: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 138: new #9 // class java/lang/StringBuilder 141: dup 142: invokespecial #10 // Method java/lang/StringBuilder."&lt;init&gt;":()V 145: ldc #19 // String str4 == str1 : 147: invokevirtual #12 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 150: aload 5 152: aload_2 153: if_acmpne 160 156: iconst_1 157: goto 161 160: iconst_0 161: invokevirtual #14 // Method java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder; 164: invokevirtual #15 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 167: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 170: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 173: new #9 // class java/lang/StringBuilder 176: dup 177: invokespecial #10 // Method java/lang/StringBuilder."&lt;init&gt;":()V 180: ldc #20 // String str4 == str3 : 182: invokevirtual #12 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 185: aload 5 187: aload 4 189: if_acmpne 196 192: iconst_1 193: goto 197 196: iconst_0 197: invokevirtual #14 // Method java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder; 200: invokevirtual #15 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 203: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 206: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 209: new #9 // class java/lang/StringBuilder 212: dup 213: invokespecial #10 // Method java/lang/StringBuilder."&lt;init&gt;":()V 216: ldc #21 // String staticNum == localNum : 218: invokevirtual #12 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 221: getstatic #22 // Field staticNum:Ljava/lang/Integer; 224: aload_1 225: if_acmpne 232 228: iconst_1 229: goto 233 232: iconst_0 233: invokevirtual #14 // Method java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder; 236: invokevirtual #15 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 239: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 242: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 245: new #9 // class java/lang/StringBuilder 248: dup 249: invokespecial #10 // Method java/lang/StringBuilder."&lt;init&gt;":()V 252: ldc #23 // String StringConstantsPool.staticStr == StaticString.staticStr : 254: invokevirtual #12 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 257: getstatic #13 // Field staticStr:Ljava/lang/String; 260: getstatic #24 // Field practice/bytecode/stringConstantsPool/StaticString.staticStr:Ljava/lang/String; 263: if_acmpne 270 266: iconst_1 267: goto 271 270: iconst_0 271: invokevirtual #14 // Method java/lang/StringBuilder.append:(Z)Ljava/lang/StringBuilder; 274: invokevirtual #15 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 277: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 280: return LineNumberTable: line 13: 0 line 14: 6 line 15: 9 line 16: 12 line 17: 23 line 18: 30 line 19: 66 line 20: 100 line 21: 135 line 22: 170 line 23: 206 line 24: 242 line 25: 280 LocalVariableTable: Start Length Slot Name Signature 0 281 0 args [Ljava/lang/String; 6 275 1 localNum Ljava/lang/Integer; 9 272 2 str1 Ljava/lang/String; 12 269 3 str2 Ljava/lang/String; 23 258 4 str3 Ljava/lang/String; 30 251 5 str4 Ljava/lang/String; static &#123;&#125;; descriptor: ()V flags: ACC_STATIC Code: stack=2, locals=0, args_size=0 0: ldc #2 // int 123456789 2: invokestatic #3 // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer; 5: putstatic #22 // Field staticNum:Ljava/lang/Integer; 8: ldc #4 // String str 10: putstatic #13 // Field staticStr:Ljava/lang/String; 13: getstatic #8 // Field java/lang/System.out:Ljava/io/PrintStream; 16: ldc #25 // String run static init block code\n 18: invokevirtual #16 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 21: return LineNumberTable: line 5: 0 line 7: 8 line 10: 13 line 11: 21&#125;SourceFile: "StringConstantsPool.java"]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>class文件常量池 运行时常量池  字符串常量池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM垃圾回收]]></title>
    <url>%2F2019%2F09%2F20%2FJVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[&emsp;垃圾收集是C++与Java的一大不同点，C++中需要手动释放内存，编写析构函数。而JVM则由后台垃圾收集线程帮我们处理垃圾对象，减少了开发人员写代码忘记编写析构，或错误析构的可能。在JVM内存结构中已经大致了解过heap堆的分代。现在的垃圾收集器基本都采用分代收集算法。因为某论文中证明大多数对象是朝生夕死的，分代算法提高垃圾收集的效率。 标记垃圾对象&emsp;那么，首先的问题是，JVM怎么知道哪些对象是需要收集的呢？在对象头的Mark Word标记字中，锁标志位（01无锁或偏向锁，00轻量级锁，10重量级锁，11GC标记）为11的话就表示该对象就要被回收了。那么是用什么方法进行标记的呢？ 引用计数法&emsp;引用计数法就是给对象加一个引用计数器，统计该对象被引用的次数，当被引用后+1，引用失效就-1，如果为0则表示当前没有其他地方引用这个对象了，就可以回收了。似乎这样的算法很简单，也容易实现。但是，存在这样一种情况，A对象引用B,而B对象又引用A，他们相互引用，那么计数则永远不可能为0，这时就无法回收A和B。所以JVM的垃圾收集一般不采用这种算法。 可达性分析-GC Roots&emsp;可达性分析算法就是 将一些对象作为根节点即GC Root，向下搜索它的字段，搜索走过的路径叫做引用链refrence Chain,那么当一个对象到 GC Roots没有一个引用链与之相连（图论中就是GC Root到这个对象不可达），那么对象就是不可用的，需要清理。如下图所示： 可达性分析-GC Roots &emsp;从图中可以看到，方法区中类的静态属性，方法区中的常量，虚拟机栈中的局部变量 可以作为GC Root,从它们出发，区分开可用和不可用对象。那么当执行系统停顿下来后，并不需要一个不漏地检查完所有局部变量和全局的引用位置，在Hotspot实现中，是使用一组称为OopMap的数据结构来直接记录哪些地方存放着对象引用。在JIT编译过程中，也会记录下栈和寄存器中哪些位置是引用，这样GC在扫描时就可以准确知道这些对象的引用。 Stop-The-World&emsp;标记完对象就要开始清理了，那这个过程最好理解的就是，把用户的线程全部停下来，垃圾收集线程开始清理，如果一边清理，用户线程一边运行，那可能就会产生新的要回收的垃圾对象。就好比，你妈妈在打扫房间，你还一个劲的往地上扔垃圾，这样怎么打扫得干净呢。所以，垃圾清理线程工作的时候，其他用户线程都应该停止。 &emsp;这个过程就叫做Stop-The-World,顾名思义，对用户Java线程，就好像全世界都停止了一样。当要进行GC的时候,JVM会告诉所有线程，我要进行GC了，那么所有线程就会暂停等待。是怎么暂停等待的呢？总不能马上停止吧（下条指令就暂停）？那么接下来就讲讲安全点safe point。 安全点与安全区&emsp;JVM已经告知了要进行GC了，线程运行到安全点，会去检查是否要GC,是则等待。那么安全点在哪呢？安全点的选择不可能太多，太多则浪费了程序性能，太少则会让GC等待时间太长。所以安全点的选定一般是以“让程序运行得更久的特征”为标准选定的,因为指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行（一般方法的代码不会太长），“长时间执行”的最明显特征就是指令序列的复用，例如方法调用（Htospot方法调用临返回前），循环跳转（uncount loop非计数循环的回跳），异常跳转等，所有具有这些功能的指令才会产生safepoint。 TODO:可以测试一下counted loop是否会进入safe point以让GC开始。好像测试结果计数循环也会产生GC啊。 &emsp;那如果线程此时不在运行（处于sleep或blocked），这样就无法运行到安全点停止，JVM也不可能等到线程唤醒后再执行到安全点中断挂起。对于这种情况就需要安全区解决。 &emsp;安全区是指在一段代码中，对象的引用关系不会发生变化。这样在这个区域的任何地方开始GC都是安全的。在线程执行到安全区的代码时，会标识自己已经进入安全区了，那样在这段时间里JVM发起GC时，就不用管标识为safe region状态的线程了。在线程离开safe region时，会检查系统是否已完成了GC(枚举GC Root或清理)，如果完成了就继续执行，否则它就必须等到收到可以离开safe region的信号为止。 详细了解 R大对safe point的解释 垃圾收集算法&emsp;这部分呢，只对算法进行一个大概的讲解。理解了算法的精髓，对于垃圾收集的整个过程也就有了整体的认识。不要求太多的细节，理解每种算法思想，它的优势，劣势。 标记-清除&emsp;标记-清除（Mark-Sweep）算法,前面已经讲过如何进行标记了，标记完后，进行清除，因为java堆是逻辑连续的（虚拟内存上看是连续，实际物理内存不一定），清理掉的对象就会形成内存碎片，那么以后在分配大对象的时候，明明还有可用内存，却无法找到一块足够放得下的内存而不得不触发另一种垃圾收集动作。这种算法易产生内存碎片，同时清理对象效率也不高。分配新对象的内存时，需要使用空闲内存列表来分配，这种分配方法叫空闲列表free-list。 标记-清除算法 复制&emsp;复制算法Copying，将内存划分为大小相等的两块，标记完成后，将可用对象复制到另一块内存，清空第一块内存，相比清除算法，这样清理动作就效率很高，同时分配内存的时候，只需要往后追加就行（指针加法bump-the-pointer），但是会有一半的内存不能使用，造成一半空间浪费。 标记-复制算法 标记-整理&emsp;标记-整理（Mark-Compact）标记完成后，将可用内存依次移动到一起，最后清除掉剩余部分的内存，这样就形成了连续的内存，不存在内存碎片。虽然清除动作很高效，但是整理的过程效率不好，还要改变对象之间引用的地址关系。 标记整理算法 #### 分代收集算法 &emsp;国外某某发布的一篇论文中证明大部分对象都是朝生夕死的，只有少部分的对象存活了下来。所以结合前面几种算法，将java堆划分为年轻代，老年代，年轻代又划分为Eden, from survivor(s0),to survivor(s1),默认比例是eden:s0:s1=8:1:1。通常在年轻代的eden区分配新对象，GC时，将eden区和from survivor中的存活对象采用复制算法复制到to survivor，然后交换s0,s1身份。如果from survivor有存活了好几代的对象，则将它晋升到老年代。如果eden + from survivor存活对象大小>to survivor大小，则有部分对象也会晋升。老年代因为是长期存活下来的对象，意味着它变动不大，当老年代因为晋升或者分配大对象而内存不够时便会发生GC,此时采用的算法一般是标记-清理或标记-整理。 年轻代使用-Xmn128m(memory new)指定大小。老年代则是当前java堆大小减去Xmn,java堆由Xms(memory start)和Xmx(memory max)指定。 分代收集算法 垃圾收集器&emsp;提前说明：下方的并发是指多个垃圾收集线程同时工作，并行是指多个垃圾收集线程与用户线程同时运行。 Serial 新生代，单线程 Serial Old 老年代，单线程 ParNew serial多线程版本，并发 Parallel Old 老年代多线程版本，并发 Parallel Scavenge（新生代、多线程并行、控制吞吐量、自适应分区比例） CMS(Concurrent Mark Sweep、老年代、多线程、并发) G1（Garbage-First，更小分区，新生和老年都收集，多线程，并行） 内存分配与回收策略新对象优先在年轻代Eden区分配&emsp;分配时有指针加法和空闲列表两种方式。并且每个线程都有自己的TLAB。 大对象直接进老年代长期存活对象进老年代&emsp;达到-XX:MaxTenuringThrehold年龄的survivor中的对象晋升到老年代 动态对象年龄判定当survivor区中存活对象相同年龄的所有对象大小大于survivor的一半，那么年龄&gt;=该年龄的对象就可以直接进入老年代，无需等到JVM选项-XX:MaxTenuringThrehold要求的年龄 空间分配担保只要老年代剩余连续可用空间大于当前新生代对象总和或历次从新生代晋升到老年代的平均晋升大小，则进行minorGC,如果失败，否则进行Full GC GC日志]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存结构]]></title>
    <url>%2F2019%2F09%2F17%2Fjvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[虚拟内存与JVM内存结构&emsp;在我们学习c语言/操作系统的时候，知道进程的内存结构有代码段，数据段[初始化数据段（初始化的全局和静态变量），未初始化数据段(又称bbs，未初始化的全局变量和静态变量)]，堆，共享库，栈，内核空间。详细了解可以搜索虚拟内存相关知识。 图1.虚拟内存结构 &emsp;虚拟机的内存结构与进程的虚拟内存结构类似，那么Java虚拟机是怎么抽象它的内存结构的呢？根据Java虚拟机规范，JVM所管理的内存包含以下几个运行时区域。可以按线程隔离和共享来分类。共享的有堆、方法区，线程隔离的有PC程序计数器、虚拟机栈、本地方法栈。如下图所示： 图2.JVM内存结构概览 程序计数器&emsp;CPU的寄存器中有一个指令寄存器IP(64位RIP,32位EIP,也称为程序计数器PC),存放下一条指令在内存中的地址。JVM内存结构中的PC可以理解为是CPU中的PC的抽象，指向的是内存中字节码指令的地址（可以简单理解为字节码指令的行号）。因为在多核CPU中，每个核跑一个线程，所以Java程序的多个线程可以同时运行，所以每个线程就需要各自的PC。如果是线程执行的是一个Java方法，那么PC记录的是指令的地址。如果是Native方法，则这个PC的值为空null。 Java虚拟机栈&emsp;同样的Java的虚拟机栈也可以理解为虚拟内存中栈的抽象。也是线程私有的，它们功能都是一样的，存储的是方法执行的栈帧（Stack Frame）。方法的调用和返回代表的就是虚拟机栈的入栈和出栈操作。栈顶就是当前线程正在执行的方法的栈帧。栈帧中存储的就是方法执行需要的一些信息，如局部变量表、操作数栈、方法出口等。 &emsp;局部变量表存放了编译器就知道了的各种基本数据类型（boolean,byte,char,short,int,float,long,double）、对象引用、returnAddress类型（指向一条字节码指令的地址）。可以把局部变量表理解为一个数组，其中long和double占用占用2个槽位（slot）,其余的都是占用1个槽位。32位虚拟机long和double用2个槽位存储数据，即使是64位的虚拟机，long和double也是2个槽位（1个槽位存储64位数据，另一个槽位为空）。 &emsp;局部变量表的大小在编译期就确定了，在运行时是不会改变其大小的。如果是对象方法的局部变量表，第一个slot是this指针，这也是为什么每个非静态方法里可以访问this的原因，静态方法则不存在this指针。然后是方法入参，然后是方法体中的局部变量。就是这样即使是我们自己，也可以很好判断局部变量表的大小。 &emsp;操作数栈就是字节码指令需要的操作数，在某些指令执行前需要提前将操作数压入操作数栈，比如iadd，则需要提前将两个整数压入操作数栈中。对应的指令是iload(从局部变量表指定位置将数据加载到操作数栈栈顶)。同样，操作数栈的大小在编译期就已经确定。 &emsp;返回地址，当一个方法被执行后，有两种方式退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion）。 另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion) 。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。 方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。 &emsp;在这个虚拟机栈中可能会出现两个异常：如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈动态扩展时申请不到足够的内存，就会抛出OutOfMemoryError异常。可以通过下方的代码进行测试 123456789101112131415161718192021222324/** * VM args: -Xss128k * */public class JavaVMStackSOF &#123; private int stackLength; public void stackLeak() &#123; stackLength ++ ; stackLeak(); &#125; public static void main(String[] args)&#123; JavaVMStackSOF javaVMStackSOF = new JavaVMStackSOF(); try &#123; javaVMStackSOF.stackLeak(); &#125; catch (Throwable e) &#123; System.out.println("stack length:"+javaVMStackSOF.stackLength); throw e; &#125; &#125;&#125; &emsp;扩展，当后面学习了class文件，字节码指令后，可以使用命令javap -v -p classfile反解析出字节码,查看局部变量表的大小，以及每个槽位存储的是什么。如下代码所示： 123456789public static void staticMethod(String str)&#123; System.out.println("static method "+str); &#125;public int virtualMethod(String word, Integer i)&#123; System.out.println(word); return i; &#125; 对应的字节码: 123456789101112131415161718192021222324252627282930313233343536public int virtualMethod(java.lang.String, java.lang.Integer); descriptor: (Ljava/lang/String;Ljava/lang/Integer;)I flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=3 0: getstatic #11 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_1 4: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 7: aload_2 8: invokevirtual #16 // Method java/lang/Integer.intValue:()I 11: ireturn LineNumberTable: line 29: 0 line 30: 7 LocalVariableTable: Start Length Slot Name Signature 0 12 0 this Lpractice/bytecode/BytecodeCommand; 0 12 1 word Ljava/lang/String; 0 12 2 i Ljava/lang/Integer;public static void staticMethod(java.lang.String); descriptor: (Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 0: getstatic #11 // Field java/lang/System.out:Ljava/io/PrintStream; 3: aload_0 4: invokevirtual #13 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 7: return LineNumberTable: line 41: 0 line 42: 7 LocalVariableTable: Start Length Slot Name Signature 0 8 0 str Ljava/lang/String; 本地方法栈&emsp;这个栈与虚拟机栈结构类似，是Native方法执行时的栈帧。不同的虚拟机有不同的实现，Hotspot虚拟机是将两者合二为一的。 Java堆&emsp;在C中，堆是动态内存区域，由malloc()函数分配内存，Hotspot虚拟机是由C++实现的，那么对象创建可能是由C++ new操作符实现的。具体的可能要看虚拟机源码才能清楚，总之，先不管是由什么实现，先理解Java虚拟机的中的堆。Java堆可以说是虚拟机中最大的一块内存了，它的唯一目的就是存放实例对象的数据，通过new出的对象和数组一般都是放到堆中的。随着JIT编译器的发展和逃逸分析技术的成熟，栈上分配、标量替换优化技术使得不再完全是堆上分配。栈上分配c语言有个函数alloca()就是进行栈上分配内存。标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间，这样就加快了数据的访问。 &emsp;Java堆是垃圾收集器管理的主要区域，这里有大量对象朝生夕死，也有老顽固存活下来。垃圾收集器基本上是分代收集算法，所以垃圾收集器把Java堆分为 年轻代{eden区、survivor区[survivor from(s0)、survicor to(s1)]}、老年代。从内存分配角度来看，为了解决并发分配对象的效率，线程共享的堆中又各自有各自的TLAB线程本地分配缓冲区（Thread Local Allocation Buffer）使用-XX:+/-UseTLAB开启关闭（默认开启）。如果不使用TLAB,那么线程在请求内存的时候就会竞争，虽然不是用synchronized同步锁住整个区域，而是使用的CAS（Compare And Swap比较并交换）加失败重试(即轻量级锁)，但仍然会存在竞争而消耗性能。而TLAB的话，线程隔离，平常分配不需要同步，只有TLAB不够分配了，申请新的TLAB才会在整个区域重新申请内存而使用同步CAS去操作。 图3.堆内存分代结构 &emsp;Java堆内存大小由Xms初始大小（memory start）,Xmx最大内存(memory max)这两个参数控制。形成可扩展的堆内存。如果申请内存时不能再扩展了，就会抛出OutOfMemoryError异常。以下是测试代码： 123456789101112131415import java.util.ArrayList;import java.util.List;public class HeapOOM &#123; public static void main(String[] args)&#123; String test = "heapOOm"; List&lt;String&gt; list = new ArrayList&lt;&gt;(100000); while (true)&#123; String str = test + test; list.add(str.intern()); &#125; &#125;&#125; 123456789Exception in thread "main" java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3210) at java.util.Arrays.copyOf(Arrays.java:3181) at java.util.ArrayList.grow(ArrayList.java:261) at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:235) at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:227) at java.util.ArrayList.add(ArrayList.java:458) at practice.heapOOM.HeapOOM.main(HeapOOM.java:13) &emsp;一般来说，引起堆OOM的，要么是系统长时间运行，存在内存泄漏leak,积少成多最终导致垃圾收集器无法回收这些没用的对象数据，要么是本身配置的内存就不够，动态扩展时申请不到内存，出现内存溢出。 方法区&emsp;从名字就可以看出来，这个区域主要是存储方法的。class文件的字节码经过类加载后就进入了方法区变成class对象，所以方法区存储的是类的相关信息（如类名、访问修饰符、运行时常量池、字段描述、方法描述等），即时编译器JIT编译后的代码等数据。GC垃圾收集器在1.7及以前把该区域叫做永久代（和堆是逻辑上连续的），1.8后叫做元空间metaspace，使用Native Memory来分配空间，这样元空间的大小就由32/64位系统的虚拟内存可用大小决定，但也可用MaxMetaspaceSize参数限制。元空间是Hotspot对方法区的具体实现。并且JDK1.7及以后把在永久代的字符串常量池移到堆内存中了。 &emsp;要测试方法区的OOM,基本思路是在运行时产生大量的类去填满方法区，直到溢出。所以，我们可以使用CGLib直接操作字节码运行时生成大量的动态类。示例代码如下： 123456789101112131415161718192021222324252627282930313233import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;import java.lang.reflect.Method;/** * VM args: -XX:MaxMetaspaceSize=10m * */public class MethodAreaClassOOM &#123; static class OOMObject&#123;&#125; public static void main(String[] args) &#123; while(true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, args); &#125; &#125;); enhancer.create(); &#125; &#125;&#125; 12345Caused by: java.lang.OutOfMemoryError: Metaspace at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:760) ... 11 more 运行时常量池&emsp;Class文件除了类的版本、字段、方法、接口等信息外，还有一项信息是常量池（Constants Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区每个类的运行时常量池，当然也会把翻译出的直接引用存储在运行时常量池中。 &emsp;扩展：比较了解 class文件常量池，运行时常量池，字符串常量池 与类加载过程的关系（待总结） 直接内存&emsp;直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也被频繁的使用，而且也可能导致OOM异常出现。在JDK1.4中新加入的NIO(New Input/Output)类，引入了一种基于通道channel的与缓冲区buffer的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样显著提升了性能，因为避免了在堆内存和Native堆中来回复制数据。 &emsp;虽然直接内存的分配不会收到Java堆的大小限制，但是会收到本机总物理内存或虚拟内存地址空间大小限制。如果配置Xmx时忽略了这部分直接内存，导致运行时加起来超过了限制，动态扩展时就会出现OOM异常。可通过-XX:MaxDirectMemorySize指定直接内存的大小。如果不指定，默认与-Xmx一样大。以下是测试OOM代码，代码越过DirectByteBuffer类，直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是只有rt.jar中的类才能使用Unsafe）。 1234567891011121314151617181920/** * VMargs: -XX:DirectMemorySize=10M * */public class DirectMemoryOOM &#123; private static final int ONE_MB = 1024 * 1024; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException &#123; Field field = Unsafe.class.getDeclaredField("theUnsafe"); field.setAccessible(true); Unsafe unsafe = (Unsafe) field.get(null); while (true) &#123; unsafe.allocateMemory(ONE_MB); &#125; &#125;&#125; 1234Exception in thread "main" java.lang.OutOfMemoryError at sun.misc.Unsafe.allocateMemory(Native Method) at practice.directMemoryOOM.DirectMemoryOOM.main(DirectMemoryOOM.java:21)]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>JVM内存结构</tag>
      </tags>
  </entry>
</search>
